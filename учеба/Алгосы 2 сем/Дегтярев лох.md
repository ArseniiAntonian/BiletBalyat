# 1. Поразрядная сортировка MSD

## **Суть поразрядной сортировки:**

Алгоритмы поразрядной сортировки рассматривают ключи, как числа, которые представлены в системе счисления с основанием R и работают с отдельными цифрами чисел

### MSD (most significant digit radix sort) - поразрядная сортировка по старшей цифре.

Идея состоит в том, чтобы выполнить следующие шаги для каждой цифры **i**, где значение **i** варьируется от старшей цифры до младшей:
- Храните элементы в разных корзинах в соответствии с их **i-м** разрядом.
- сортируйте каждую ячейку, содержащую более одного элемента.
- ![[Pasted image 20240611215607.png]]

### Проблемы настройки

- **если R принимает чрезмерно большое значение, то большая часть стоимости сортировки приходится на инициализацию и проверку корзин;**
- **если R недостаточно велико, то метод не использует своих потенциальных выгод, что достигается, если разделить исходный файл на максимально возможное число фрагментов.**

### Проблема пустых корзин
При сортировке случайных ключей количество ключей в каждом контейнере (размер подфайлов) после первого прохода в среднем будет равно N/R. На практике ключи могут не быть случайными (например, если ключи — это строки, представляющие собой слова на русском языке, то мы знаем, что лишь немногие из них начинаются с буквы й и совсем нет слов, начинающихся с буквы ъ), так что многие контейнеры окажутся пустыми, а некоторые из непустых контейнеров будут содержать больше ключей, чем остальные.
Пути решения:
- **Эвристика в масштабах корзины (bin-span-heuristics) - 
	- **First Fit (Первое подходящее)**:
	    - Элементы рассматриваются последовательно, и каждый элемент помещается в первый контейнер, который может его вместить во всех измерениях. Этот метод прост в реализации, но не всегда находит оптимальное решение.
	- **Best Fit (Лучшее подходящее)**:
	    - Элементы рассматриваются последовательно, и каждый элемент помещается в контейнер, который оставляет наименьшее свободное пространство после его добавления. Этот метод более вычислительно затратен, но часто дает лучшие результаты по сравнению с First Fit.
	- **Next Fit (Следующее подходящее)**:
	    - Элементы рассматриваются последовательно, и каждый элемент помещается в текущий контейнер, если он подходит, иначе открывается новый контейнер. Этот метод ограничивает количество открытых контейнеров, что может быть полезно в некоторых приложениях.**
- **Разработка более сложной реализации абстрактной операции доступа к конкретным байтам, которая учитывает любые специальные знания о сортируемых строках.**

### Сложность

Пусть значения разрядов меньше b, а количество разрядов — k. При сортировке массива из одинаковых элементов MSD-сортировкой на каждом шаге все элементы будут находится в неубывающей по размеру корзине, а так как цикл идет по всем элементам массива, то получим, что время работы MSD-сортировки оценивается величиной **O(nk)**, причем это время нельзя улучшить. Хорошим случаем для данной сортировки будет массив, при котором на каждом шаге каждая корзина будет делиться на b частей. Как только размер корзины станет равен 1, сортировка перестанет рекурсивно запускаться в этой корзине. Таким образом, асимптотика будет Ω(n logb(n)). Это хорошо тем, что не зависит от числа разрядов.

По памяти O(k), по сути O(n)
### **Условие поразрядной сортировки:**

Основное условие поразрядной сортировки состоит в том, чтобы мы могли разделить ключ, строку, последовательность байтов, которые мы могли бы сравнивать по отдельности, то есть выбирать какие-то определенные части и сравнивать их.

### **Абстракции для работы поразрядной сортировки (с чем она может работать):**

1. Байт - последовательность битов фиксированной длины

2. Строка - последовательность байтов переменной длины

3. Слово - последовательность байтов фиксированной длины

4. Ключ - число в системе счисления с основанием R, цифры которого пронумерованы. (организованы как последовательности байтов)

Все эти абстракции можно разделить на части, которые можно сравнивать

### Частный случай: двоичная поразрядная сортировка:

1. У каждого элемента изначально имеется ключ в двоичной системе счисления, выбираем самый большой разряд, по нему будем сортировать
2. Где единица - вниз, они больше, с 0 вверх, они меньше
3. Получили два блока, далее в каждом блоке берем второй разряд, он будет страшим и уже к каждому из блоков рекурсивно применяем алгоритм сортировки

Суть: Делим на 2 блока, с нулями и единицами в старшем разряде и рекурсивно сортируем по старшему разряду, пока не дойдем до конца ключа

Пример:
![[Pasted image 20240611222130.png]]

Суть: модификация двоичной поразрядной сортировки, только вместо двоичной СС, у нас СС, с основанием R, получается, что наш алгоритм делит на k частей, называемых корзинами и затем в каждой из этих корзин сортирует рекурсивно также разделяя на k частей, пока не дойдет до конца

### Преимущества и недостатки:

- Хорошо параллелится, при этом даже без этого является очень быстрой
- Требует дополнительную память и не всегда работает. Например, на знаковых числах (просто для разных знаков сортировать - неэффективно). Также не очень эффективен, когда много одинаковых элементов
# 2. Трех-путевая поразрядная быстрая сортировка
### Постановка задачи:

Допустим, мы выполняем сортировку строк.

Использовать qsort, который активно сравнивает элементы, выглядит слишком накладным — сравнение строк операция долгая. Да, мы можем написать свой компаратор, который будет несколько эффективнее. Но все же.

Использовать radix, который требует дополнительную память, тоже не слишком мотивирует — строки могут быть большими. Да и большая длина строк, т.е. число разрядов, удручающе сказываются на эффективности.
### Основная идея

**Приспособить быструю сортировку для MSD, используя трехпутевое разделение ключей по старшим байтам с переходом к следующему байту только в среднем подфайле.**

Это комбинация быстрой и поразрядной сортировки.

1. Берем опорный элемент.
2. Разделяем массив на три части, сравнивая элементы с опорным по старшему разряду — на меньшие, равные и большие.
3. В каждой из трех частей процедуру повторяем, начиная с шага №1, до тех пор, не дойдем до пустых частей или частей с 1 элементом.

Только в средней части (т.е. где старший разряд равен старшему разряду опорного элемента) переходим к следующему разряду. В остальных частях операция начинается без изменения «рабочего» разряда.

Пример:
![[Pasted image 20240611222618.png]]

### Сложность:

По сути работает схожим образом, как и быстрая сортировка, по методу “разделяй и властвуй”, поэтому сложность:

**Сложность сортировки — O(n*logn).**

**Дополнительная память — O(1).**

### Преимущества:

- По сравнению с быстрой в том, что нам не нужно выполнять сравнение каждого элемента целиком, что естественно ускоряет процесс
- По сравнению с поразрядной - не требует дополнительной памяти

### Недостатки:

- Более сложна в написании, чем быстрая сортировка
- Хуже параллелится по сравнению с поразрядной сортировкой 
# 3. Поразрядная сортировка LSD
### LSD (least significant digit radix sort) - поразрядная сортировка сначала по младшей цифре.

**Альтернативный метод поразрядной сортировки
› Сортируем по последней букве (используем метод подсчета индексных ключей)
› Сортируем по средней букве


**Работает только в том случае, если доказана устойчивость метода сортировки**

Идея: сортировать элементы не от большего разряда к меньшему, а наоборот

### Алгоритм:

1. Берем последние разряды чисел и поводим сортировку по ним, любой сортировкой, главное, чтобы она была устойчивой(наиболее эффективно, конечно, будет использовать сортировку подсчетом. Именно для нее будет потом рассчитана сложность)
2. Переходим к предпоследнему элементу, также сортируем
3. Производим операции до тех пор, пока не дойдем до конца.

### Почему сортировка должна быть устойчивой?

Если значения разрядов чисел не равны между собой, то элементы могут перемещаться между группами на каждом шаге. Поэтому при реализации LSD sort необходимо использовать стабильную сортировку внутри каждой группы.

Пояснение:

Предположим, что мы используем, неустойчивую сортировку, тогда элементы не сохраняют относительный порядок. Из этого следует, что относительный порядок, который мы задали, никак не будет задействован, из чего следует, что элементы, у которых, все одинаковы разряды, кроме, например, последнего, стоят так, что не удовлетворяют отсортированности, из чего можно сделать вывод, что сортировка не работает

### Сложность

Пусть m — количество разрядов, n — количество объектов, которые нужно отсортировать, T(n) — время работы устойчивой сортировки. Цифровая сортировка выполняет k итераций, на каждой из которой выполняется устойчивая сортировка и не более O(1) других операций. Следовательно время работы цифровой сортировки — O(kT(n)).

Рассмотрим отдельно случай сортировки чисел. Пусть в качестве аргумента сортировке передается массив, в котором содержатся n m-значных чисел, и каждая цифра может принимать значения от 0 до k−1. Тогда цифровая сортировка позволяет отсортировать данный массив за время O(m(n+k)), если устойчивая сортировка имеет время работы O(n+k). Если k небольшое, то оптимально выбирать в качестве устойчивой сортировки сортировку подсчетом.

Если количество разрядов — константа, а k=O(n), то сложность цифровой сортировки составляет O(n), то есть она линейно зависит от количества сортируемых чисел.

### Преимущества и недостатки:

1. Устойчива, довольно быстрая
2. Требует дополнительные затраты памяти и не всегда работает или делает это неэффективно(аналогично MSD)
# 4. Графы и их разновидности
### Граф - совокупность узлов и ребер, соединяющих эти узлы, как структура данных.

### Разновидности графов:

- **Неориентированный/ориентированный**

	G=(V,E) – неориентированный, если из (x,y)∈E следует, что (y,x) также является членом E. В противном случае граф – ориентированный.

- **Взвешенный/Невзвешенный**

	Каждому ребру/вершине взвешенного графа G присваивается числовое значение или вес.

- **Простые/Сложные**
	![[Pasted image 20240611223823.png]]
- **Разреженные/Плотные**
	![[Pasted image 20240611223930.png]]

- **Циклические/Ациклические**
	![[Pasted image 20240611224040.png]]

- **Явные/Неявные**
	![[Pasted image 20240611224112.png]]

- **Вложенные/Топологические**
	![[Pasted image 20240611224133.png]]

- **Помеченные/Непомеченные**
	![[Pasted image 20240611224258.png]]
- **Дерево**
	Дерево - любой связанный граф, не содержащий циклов
	
	Связанный граф - граф, между любой парой вершин которого существует хотя бы 1 путь
# 5. Обход графов, раскраска графов
# Обход графов
### **Обход графа - систематизированное посещение каждой вершины и каждого ребра графа.**

Каждая из вершин находится в одном из состояний: 
- Неоткрытая – первоначальное, нетронутое состояние вершины
- Открытая – вершина обнаружена, но не проверены все ее ребра
- Обработанная – все инцидентные данной вершине ребра были посещены

### Обход в ширину (breadth-first search, BFS)

Идея: берем, изначально, какую-нибудь вершину, помечаем ее. Далее мы берем для этой вершины все вершины, смежные с ней. Заходим в каждую. Если были в ней, то ничего не делаем, если в ней не были, то берем все вершины, смежные с данной. Далее то же самое повторяем, для вершин, которые взяли (т.е. мы каждый раз берем все смежные вершины данной, тем самым каждый раз расширяемся в ширину).

### **Обход в глубину (depth-first search, DFS)**

Идея: выбрать изначально любую вершину графа, и идти по какому-нибудь одному пути, помечая при этом все вершины, в которых были, пока не дойдем до вершины, которую уже посетили, или до вершины, из которой нельзя попасть в другие вершины. (т.е. постоянно спускаемся в глубь). Затем поднимаемся на одну вершину вверх, от той, которая оказалась конечной и повторяем то же самое

Замечание: оба алгоритма являются взаимозаменяемыми, но иногда какой-то из них использовать более выгодно чем другой.

# Раскраска графов

пусть G - некоторый граф, k - натуральное число. тогда раскраской графа называется функция f, которая каждой вершине графа G ставит в соответствие определенные номер {1,…, k}

Раскраска называется правильной, если любым двум смежным вершинам не соответствует одно и то же число, при этом k - минимальное число для этого графа.

_Пояснение:_ раскраска будет правильной, если у нас смежные вершины не раскрашены в один и тот же цвет, при этом мы задействовали минимальное количество цветов.(граф помечен определенным числом, можно визуализировать как граф раскрашен в определенный цвет)
![[Pasted image 20240611224857.png]]
## Двудольная раскраска графов

Задача: раскрасить граф в 2 цвета

Заметим, что если такая раскраска существует, и если зафиксировать цвет одной вершины, то все цвета всех достижимых из неё вершин определяются однозначно: пусть цвет этой вершины белый, тогда все её соседи будут иметь черный цвет, все вершины на расстоянии 2 будут иметь снова белый цвет, все вершины на расстоянии 3 снова черный, и так далее.

Раскрашивать граф можно обходом в глубину. На этот раз наш DFS будет принимать параметром цвет, в который нужно покрасить вершину, и он будет рекурсивно запускаться от всех соседей, крася их в противоположный цвет. По окончании работы алгоритма мы либо обнаружим, что граф не двудолен (мы когда-то посмотрели на две соседние вершины, которым нужно присвоить один и тот же цвет), либо найдём разбиение вершин графа на две доли.
**Пример**
 - Предположим, что в ВУЗе есть N преподавателей. Каждый должен прочитать определенное количество лекций по своему предмету, притом разные преподаватели могут читать свои лекции параллельно, один преподаватель так не может. Каждая лекция пусть занимает 1 час.
- Задача: составить расписание лекций так, чтобы они были прочтены для всех групп за минимальное время (т.е. по сути были прочтены за минимальное количество дней, значит надо сделать так, чтобы было как можно меньше окон)
- Пусть каждая лекция - это вершина графа, смежные вершины те, которые читает один и тот же преподаватель, смежные вершины раскрашиваем в разные цвета. Получаем некоторую раскраску, при этом, если вершины имеют 1 раскраску, то они могут читаться параллельно, значит их можно поставить в расписание на 1 время, если сделаем правильную раскраску, то по сути найдем максимальное количество лекций, которые можно ставить параллельно, при этом получим, что если мы так расставим лекции, то все лекции будут прочтены за минимальное количество часов

подгон от Коли:

[](https://www.youtube.com/watch?v=qoIEi0KA5Xc&t=336s&ab_channel=%D0%A3%D1%87%D0%B8%D0%BC%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B9%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8)[https://www.youtube.com/watch?v=qoIEi0KA5Xc&t=336s&ab_channel=Учималгоритмыдискретнойматематики](https://www.youtube.com/watch?v=qoIEi0KA5Xc&t=336s&ab_channel=%D0%A3%D1%87%D0%B8%D0%BC%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B9%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8)
# 6. Алгоритм обхода в ширину по сравнению с обходом в глубину
### **Обход в ширину (breadth-first search, BFS)**

**Идея**: берем, изначально, какую-нибудь вершину, помечаем ее. Далее мы берем для этой вершины все вершины, смежные с ней. Заходим в каждую. Если были в ней, то ничего не делаем, если в ней не были, то берем все вершины, смежные с данной. Далее то же самое повторяем, для вершин, которые взяли (т.е. мы каждый раз берем все смежные вершины данной, тем самым каждый раз расширяемся в ширину).

Получается, что при каждой операции мы проверяем, является ли вершина посещенной и, если нет, то собираем все вершины, смежные ей, и даем им самый низкий приоритет. Далее берем еще одну, с нее собираем смежные и даем им самый низкий приоритет, значит приоритет вершин, добавленных до этого надо увеличить. Таким образом, мы приходим к выводу, что для реализации обхода в ширину мы будем использовать структуру данных - очередь, в отличие от обхода в глубину, где мы использовать будем стек.

**Очередь** - обход в ширину. Помещая вершины в очередь типа FIFO, мы исследуем самые старые неисследованные вершины первыми. Таким образом, наше исследование медленно распространяется вширь, начиная от стартовой вершины.

### Итеративный алгоритм

1. Выбираем вершину и кладем ее в очередь
2. Достаем из очереди вершину, помечаем ее как открытую
3. Если вершина изначально не была открытой, то кладем в очередь все вершины, смежные ей
4. Повторяем шаги 2, 3 до тех пор, пока очередь не окажется пустой

### Свойства при обходе в ширину

- _Сохранение порядка, в котором мы открывали вершины графа, и пути позволяет определить минимальный путь от исходной вершины до любой заданной (поскольку у каждой вершины есть только один родитель)._
- Ребра графа, которые не включены в дерево обхода в ширину, также имеют особые свойства. Для неориентированных графов, не попавшие в дерево ребра могут указывать только на вершины на том же уровне, что и родительская вершина, или на вершины, расположенные на уровень ниже. Эти свойства естественно следуют из того факта, что каждое ребро в дереве должно быть кратчайшим путем в графе (есть вершина, если с вершиной, смежной с ней, изначально нет ребра в дереве вершин, то тогда значит, что смежная вершина или на том же уровне с деревом или на 1 уровень ниже).
- Для ориентированных графов ребро (u, v), указывающее в обратном направлении, может существовать в любом случае, когда вершина v расположена ближе к корню, чем вершина u.(у нас есть ребро (u,v). Если v ближе к корню чем u, то ребро (u, v) обязательно может существовать, хотя это не гарантируется)

### Преимущества обхода в ширину, по сравнению с обходом в глубину

- Одним из основных преимуществ обхода в ширину по сравнению с обходом в глубину является то, что он может быть использован для поиска кратчайшего пути в невзвешенном графе. Обход в ширину гарантирует, что кратчайший путь будет найден, если все ребра имеют одинаковый вес. Кроме того, обход в ширину может быть более эффективным при работе с графами, у которых много ребер, но мало уровней.
- Еще одним преимуществом обхода в ширину является то, что он может быть использован для поиска компонент связности в неориентированном графе. Обход в ширину позволяет найти все вершины, которые достижимы из заданной вершины, и таким образом определить компонент связности (максимального связного подграфа).
- Кроме того, обход в ширину может быть более удобным для работы с графами, у которых нет определенной структуры или которые содержат циклы. Обход в ширину позволяет посетить все вершины графа, не застревая в циклах или повторно посещая вершины.
# 7. Алгоритм обхода в глубину по сравнению с обходом в ширину
### **Обход в глубину (depth-first search, DFS)**

**Идея**: выбрать изначально любую вершину графа, и идти по какому-нибудь одному пути, помечая при этом все вершины, в которых были, пока не дойдем до вершины, которую уже посетили, или до вершины, из которой нельзя попасть в другие вершины. (т.е. постоянно спускаемся вглубь). Затем поднимаемся на одну вершину вверх, от той, которая оказалась конечной и повторяем то же самое.

Получается, что мы берем одну вершину, далее, собираем все смежные вершины и даем им максимальный приоритет, переходи-м в одну из них, если не открытая, то снова собираем все смежные вершины и даем им максимальный приоритет. Тем самым приходим к выводу, что нам необходимо использовать стек (или рекурсию, как замену ему)

**Стек** – обход в глубину. Помещая вершины в стек с порядком извлечения LIFO, мы исследуем их, отклоняясь от пути для посещения очередного соседа, и возвращаясь назад, только если оказываемся в окружении ранее открытых вершин. Таким образом, мы в своем исследовании быстро удаляемся от стартовой вершины.

### Итеративный алгоритм

1. Берем вершину и кладем (!!!) ее в стек
2. Вытаскиваем из стека и отмечаем, как открытую
3. Если до этого вершина была закрытой, то кладем в стек все вершины, смежные с ней
4. Повторяем шаги 2-3 до тех пор, пока стек не будет пуст

### Рекурсивный алгоритм

1. берем первую вершину, и запускаем для нее функцию проверки на открытость
2. Если вершина открытая, то завершаем, если нет, то помечаем, как открытую и для каждой вершины, смежной ей запускаем рекурсивно ту же функцию
3. Алгоритм завершится, когда стек рекурсий будет пуст

### Свойства при обходе в глубину

- Посещение предшественника. Если вершина х является предшественником вершины у в дереве обхода в глубину, то временной интервал посещения у должен быть корректно учтен его предшественником
- Количество потомков. Разница во времени выхода и входа для вершины у свидетельствует о количестве потомков этой вершины в дереве обхода в глубину.

**Обход в глубину разбивает ребра на два класса:**

- древесные (tree edges) - используются при открытии новых вершин и закодированы в родительском отношении
- обратные (back edges) - второй конец является предшественником расширяемой вершины

### Преимущество обхода в глубину по сравнению с обходом в ширину

- Один из главных преимуществ обхода в глубину по сравнению с обходом в ширину заключается в том, что он использует меньше памяти. В обходе в ширину необходимо хранить все вершины на текущем уровне, а также все вершины на предыдущих уровнях, что может потребовать значительных объемов памяти при работе с большими графами. В обходе в глубину же используется стек для хранения вершин, что позволяет эффективно использовать память и работать с графами большого размера.
- Кроме того, обход в глубину может быть более эффективен при поиске определенных типов путей или структур в графе, таких как циклы, деревья или компоненты связности. Обход в глубину также может быть более простым и интуитивно понятным для реализации, особенно для начинающих программистов.
# 8. Обход ориентированных графов, топологическая сортировка
# Обход ориентированных графов

Для ориентированных графов обход в глубину и ширину по идее схожи. Итак, при работе с ориентированными графами часто бывает такая ситуация, что граф не является связным, значит до некоторых вершин алгоритм может не дойти, если мы выберем определенную вершину (мы можем выбирать любую вершину для начала работы алгоритма). Значит, чтобы захватить все вершины, необходимо после отработки алгоритма запустить его ещё раз, но в этот раз взять за корень не посещенную вершину.

### Алгоритм:

1. Проверяем посещена ли вершина
2. Если не посещена, то запускаем DFS(BFS) c корнем в этой вершине
3. повторяем шаги 1, 2 до тех пор, пока все вершины не будут посещены

### Применение обхода в глубину для определения вида ребра в ориентированном графе

Древесный граф - это граф, который является связным и не имеет циклов. Древесное ребро - это ребро, которое принадлежит древесному графу и соединяет две вершины в этом графе, при этом не является частью цикла. То есть, если удалить древесное ребро, граф разобьется на два подграфа.

При обходе в глубину неориентированного графа DFS разделяет все ребра на древесные и обратные. При обходе в глубину для ориентированного графа разделение ребер идет на 4 класса:
![[Pasted image 20240611230114.png]]

Также при помощи этого алгоритма можно определять тип ребра в ориентированном графе, это является очень полезным при разработке алгоритмов для работы с ориентированными графами

### Алгоритм определения типа ребра в графе:
![[Pasted image 20240611230135.png]]
**Пояснение**: во время работы алгоритма мы перешли в какую-то вершину, мы ее зафиксировали и передаем в функцию, как вершину y. Вершина x - вершина, которая имеет с y ребро(может, кстати, быть такая ситуация, что ребро есть, а какая-то вершина не найдена, но она будет найдена потом, поэтому в общем случае мы рассматриваем в качестве x не все вершины, а только найденные).

1. Если x - родитель y, то ребро древесное
2. Если вершина была посещена (метка посещения ставится после вызова функции) до этого, при этом не является обработанной (не все вершины, для который она родитель посещены), то ребро обратное
3. Если обработана и при этом время нахождения вершины y больше x, то ребро прямое
4. Если время y меньше времени x, то ребро поперечное

# Топологическая сортировка

Задача: упорядочить вершины вдоль линии таким образом, что все ориентированные ребра направлены слева направо

_Замечание:_ такое упорядочивание ребер невозможно в графе, содержащем ориентированный цикл, так как в таком графе не существует линейного порядка вершин. Любой, бесконтурный ориентированный граф (не содержит обратных ребер) имеет, по крайней мере, одно топологическое упорядочивание

### Зачем нужна?

Важность топологической сортировки состоит в том, что она позволяет упорядочить вершины графа таким образом, что каждую вершину можно обработать перед обработкой ее потомков. Допустим, что ребра представляют управление очередностью таким образом, что ребро (х, у) означает, что работу х нужно выполнить раньше, чем работу у. Тогда любое топологическое упорядочивание определяет правильное календарное расписание. Более того, бесконтурный орграф может содержать несколько таких упорядочиваний.

### Процедура топологической сортировки

- **Если вершина y не открыта, то начинаем обход в глубину из вершины у, прежде чем можем продолжать исследование вершины х**
- **Если вершина у открыта, но не обработана, то ребро (х,у) является обратным ребром, что запрещено в бесконтурном ориентированном графе**
- **Если вершина у обработана, то она помечается соответствующим образом раньше вершины х**